{% extends 'layouts/base.html' %}

{% block title %} Breadcrumbs {% endblock title %}

<!-- Specific CSS goes HERE -->
{% block stylesheets %}{% endblock stylesheets %}

{% block body_class %} breadcrumbs-sections {% endblock body_class %}

{% block content %}
  
  {% include "includes/navigation-light.html" %}

  <div class="container mt-5">
    <div class="row">
      <div class="col-lg-12 mx-auto">
        <div class="mb-4 w-25">
          <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
              <li class="breadcrumb-item"><a href="/presentation.html">Weather Station</a></li>
              <li class="breadcrumb-item active" aria-current="page">Python Code</li>
            </ol>
          </nav>
          <h3>Python Code</h3>
        </div>
        <div class="position-relative border-radius-xl overflow-hidden shadow-lg mb-7">
          <div class="container border-bottom">
            <div class="row justify-space-between py-2">
              <div class="col-lg-3 me-auto">
                <p class="lead text-dark pt-1 mb-0">Python Code</p>
              </div>
              <div class="col-lg-3">
                <div class="nav-wrapper position-relative end-0">
                  <ul class="nav nav-pills nav-fill flex-row p-1" role="tablist">
                    <li class="nav-item">
                      <a class="nav-link mb-0 px-0 py-1 active" data-bs-toggle="tab" href="#preview-breadcrumb" role="tab" aria-controls="preview" aria-selected="true">
                        <i class="fas fa-desktop text-sm me-2"></i> Preview
                      </a>
                    </li>
                    <li class="nav-item">
                      <a class="nav-link mb-0 px-0 py-1" data-bs-toggle="tab" href="#code-breadcrumb" role="tab" aria-controls="code" aria-selected="false">
                        <i class="fas fa-code text-sm me-2"></i> Code
                      </a>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
          <div class="tab-content tab-space">
            <div class="tab-pane active" id="preview-breadcrumb">
              <iframe width="100%" height="800px" srcdoc='<!doctype html>
                <html>
    <head>
      
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

<script>hljs.highlightAll();</script>
    </head>
    <body>
      
      <pre><code class="language-python" >             

#!/usr/bin/env python

  import bme680
  from datetime import datetime
  import time
  import psycopg2
  
  print("""
  
  Runs the sensor for a burn-in period, then uses a
  combination of relative humidity and gas resistance
  to estimate indoor air quality as a percentage.
  
  Press Ctrl+C to exit!
  
  """)
  
  # Connect to the PostgreSQL database
  conn = psycopg2.connect(
      dbname="qdb",
      user="admin",
      password="quest",
      host="docker_host_ip_address",
      port="8812"
  )
  
  # Create the necessary table if it does not exist
  with conn:
      cursor = conn.cursor()
      cursor.execute("CREATE TABLE  IF NOT EXISTS weather_data (temperature DOUBLE, humidity DOUBLE, pressure DOUBLE, gas_resistance DOUBLE, iaq DOUBLE, timestamp TIMESTAMP) TIMESTAMP(timestamp) PARTITION BY DAY;")
  
  
  # Initialize the BME680 sensor
  # These oversampling settings can be tweaked to
  # change the balance between accuracy and noise in
  # the data.
  
  try:
      sensor = bme680.BME680(bme680.I2C_ADDR_PRIMARY)
  except (RuntimeError, IOError):
      sensor = bme680.BME680(bme680.I2C_ADDR_SECONDARY)
  
  # Configuration for the BME680 sensor
  # These oversampling settings can be tweaked to
  # change the balance between accuracy and noise in
  # the data.
  sensor.set_humidity_oversample(bme680.OS_2X)
  sensor.set_pressure_oversample(bme680.OS_4X)
  sensor.set_temperature_oversample(bme680.OS_8X)
  sensor.set_filter(bme680.FILTER_SIZE_3)
  sensor.set_gas_status(bme680.ENABLE_GAS_MEAS)
  sensor.set_gas_heater_temperature(320)
  sensor.set_gas_heater_duration(150)
  sensor.select_gas_heater_profile(0)
  
  # Collect burn-in data for gas sensor
  # start_time and curr_time ensure that the
  # burn_in_time (in seconds) is kept track of.
  
  start_time = time.time()
  curr_time = time.time()
  burn_in_time = 290
  burn_in_data = []
  
      # Collect gas resistance burn-in values, then use the average
      # of the last 50 values to set the upper limit for calculating
      # gas_baseline.
  
  print('Collecting gas resistance burn-in data for 5 mins\n')
  
  while curr_time - start_time < burn_in_time:
      curr_time = time.time()
      if sensor.get_sensor_data() and sensor.data.heat_stable:
          gas = sensor.data.gas_resistance
          burn_in_data.append(gas)
          print('Gas: {0} Ohms'.format(gas))
          time.sleep(1)
  
  gas_baseline = sum(burn_in_data[-50:]) / 50.0
  
  # Set the humidity baseline to 40%, an optimal indoor humidity
  hum_baseline = 40.0
  
    # This sets the balance between humidity and gas reading in the
  # calculation of air_quality_score (25:75, humidity:gas)
  hum_weighting = 0.25
  
  print('Gas baseline: {0} Ohms, humidity baseline: {1:.2f} %RH\n'.format(
          gas_baseline,
          hum_baseline))
  
  # Collect and process data indefinitely
  while True:
      if sensor.get_sensor_data() and sensor.data.heat_stable:
          temperature = sensor.data.temperature
          humidity = sensor.data.humidity
          pressure = sensor.data.pressure
          gas_resistance = sensor.data.gas_resistance 
          timestamp = datetime.now()
  
          
          gas_offset = gas_baseline - gas_resistance
          hum_offset = humidity - hum_baseline
  
      # Calculate hum_score as the distance from the hum_baseline.
          if hum_offset > 0:
              hum_score = (100 - hum_baseline - hum_offset) / (100 - hum_baseline) * (hum_weighting * 100)
          else:
              hum_score = (hum_baseline + hum_offset) / hum_baseline * (hum_weighting * 100)
      
      # Calculate gas_score as the distance from the gas_baseline.
          if gas_offset > 0:
              gas_score = (gas_resistance / gas_baseline) * (100 - (hum_weighting * 100))
          else:
              gas_score = 100 - (hum_weighting * 100)
  
          # Calculate air_quality_score.
          iaq = hum_score + gas_score
  
          # Insert data into the database
          with conn:
              cursor = conn.cursor()
              # Insert sensor data into the table
              insert_query = "INSERT INTO weather_data (temperature, humidity, pressure, gas_resistance, iaq, timestamp) VALUES (%s, %s, %s, %s, %s, %s);"
              cursor.execute(insert_query, (temperature, humidity, pressure, gas_resistance, iaq, timestamp))
  
          print("Sensor data inserted:", temperature, humidity, pressure, gas_resistance, iaq, timestamp)
        
          time.sleep(60)  # Wait for 60 seconds before next reading

        </code></pre>
        </body></html>
        </div>
        
                '></iframe>

                
            </div>
            <div class="tab-pane" id="code-breadcrumb">
              <div class="position-relative p-4 pb-2">
                <a class="btn btn-sm bg-gradient-dark position-absolute end-4 mt-3" onclick="copyCode(this);" type="button"><i class="fas fa-copy text-sm me-1"></i> Copy</a>
                <figure class="highlight"><pre><code class="language-html" data-lang="html">#!/usr/bin/env python

                    import bme680
                    from datetime import datetime
                    import time
                    import psycopg2
                    
                    print("""
                    
                    Runs the sensor for a burn-in period, then uses a
                    combination of relative humidity and gas resistance
                    to estimate indoor air quality as a percentage.
                    
                    Press Ctrl+C to exit!
                    
                    """)
                    
                    # Connect to the PostgreSQL database
                    conn = psycopg2.connect(
                        dbname="qdb",
                        user="admin",
                        password="quest",
                        host="docker_host_ip_address",
                        port="8812"
                    )
                    
                    # Create the necessary table if it doesn't exist
                    with conn:
                        cursor = conn.cursor()
                        cursor.execute("CREATE TABLE  IF NOT EXISTS weather_data (temperature DOUBLE, humidity DOUBLE, pressure DOUBLE, gas_resistance DOUBLE, iaq DOUBLE, timestamp TIMESTAMP) TIMESTAMP(timestamp) PARTITION BY DAY;")
                    
                    
                    # Initialize the BME680 sensor
                    # These oversampling settings can be tweaked to
                    # change the balance between accuracy and noise in
                    # the data.
                    
                    try:
                        sensor = bme680.BME680(bme680.I2C_ADDR_PRIMARY)
                    except (RuntimeError, IOError):
                        sensor = bme680.BME680(bme680.I2C_ADDR_SECONDARY)
                    
                    # Configuration for the BME680 sensor
                    # These oversampling settings can be tweaked to
                    # change the balance between accuracy and noise in
                    # the data.
                    sensor.set_humidity_oversample(bme680.OS_2X)
                    sensor.set_pressure_oversample(bme680.OS_4X)
                    sensor.set_temperature_oversample(bme680.OS_8X)
                    sensor.set_filter(bme680.FILTER_SIZE_3)
                    sensor.set_gas_status(bme680.ENABLE_GAS_MEAS)
                    sensor.set_gas_heater_temperature(320)
                    sensor.set_gas_heater_duration(150)
                    sensor.select_gas_heater_profile(0)
                    
                    # Collect burn-in data for gas sensor
                    # start_time and curr_time ensure that the
                    # burn_in_time (in seconds) is kept track of.
                    
                    start_time = time.time()
                    curr_time = time.time()
                    burn_in_time = 290
                    burn_in_data = []
                    
                        # Collect gas resistance burn-in values, then use the average
                        # of the last 50 values to set the upper limit for calculating
                        # gas_baseline.
                    
                    print('Collecting gas resistance burn-in data for 5 mins\n')
                    
                    while curr_time - start_time < burn_in_time:
                        curr_time = time.time()
                        if sensor.get_sensor_data() and sensor.data.heat_stable:
                            gas = sensor.data.gas_resistance
                            burn_in_data.append(gas)
                            print('Gas: {0} Ohms'.format(gas))
                            time.sleep(1)
                    
                    gas_baseline = sum(burn_in_data[-50:]) / 50.0
                    
                    # Set the humidity baseline to 40%, an optimal indoor humidity
                    hum_baseline = 40.0
                    
                      # This sets the balance between humidity and gas reading in the
                    # calculation of air_quality_score (25:75, humidity:gas)
                    hum_weighting = 0.25
                    
                    print('Gas baseline: {0} Ohms, humidity baseline: {1:.2f} %RH\n'.format(
                            gas_baseline,
                            hum_baseline))
                    
                    # Collect and process data indefinitely
                    while True:
                        if sensor.get_sensor_data() and sensor.data.heat_stable:
                            temperature = sensor.data.temperature
                            humidity = sensor.data.humidity
                            pressure = sensor.data.pressure
                            gas_resistance = sensor.data.gas_resistance 
                            timestamp = datetime.now()
                    
                            
                            gas_offset = gas_baseline - gas_resistance
                            hum_offset = humidity - hum_baseline
                    
                        # Calculate hum_score as the distance from the hum_baseline.
                            if hum_offset > 0:
                                hum_score = (100 - hum_baseline - hum_offset) / (100 - hum_baseline) * (hum_weighting * 100)
                            else:
                                hum_score = (hum_baseline + hum_offset) / hum_baseline * (hum_weighting * 100)
                        
                        # Calculate gas_score as the distance from the gas_baseline.
                            if gas_offset > 0:
                                gas_score = (gas_resistance / gas_baseline) * (100 - (hum_weighting * 100))
                            else:
                                gas_score = 100 - (hum_weighting * 100)
                    
                            # Calculate air_quality_score.
                            iaq = hum_score + gas_score
                    
                            # Insert data into the database
                            with conn:
                                cursor = conn.cursor()
                                # Insert sensor data into the table
                                insert_query = "INSERT INTO weather_data (temperature, humidity, pressure, gas_resistance, iaq, timestamp) VALUES (%s, %s, %s, %s, %s, %s);"
                                cursor.execute(insert_query, (temperature, humidity, pressure, gas_resistance, iaq, timestamp))
                    
                            print("Sensor data inserted:", temperature, humidity, pressure, gas_resistance, iaq, timestamp)
                          
                            time.sleep(60)  # Wait for 60 seconds before next reading</code></pre>
                </figure>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

{% endblock content %}

<!-- Specific JS goes HERE --> 
{% block javascripts %}

  <script src="/static/assets/js/soft-design-system.min.js?v=1.0.1" type="text/javascript"></script>

{% endblock javascripts %}
